def euclidian_distance(point_a, point_b):
    return (sum([(point_a[i] - point_b[i])**2 for i in range(len(point_a))]))**0.5


class KMeans:
    def __init__(self, k):
        self.k = k

    def find_cluster_centroid(self, cluster_points: list) -> dict:
        '''
        This function finds the cluster centroids from the given cluster points.
        It uses the Euclidean distance to find the closest centroid for each point,
        and returns a dictionary where keys are centroids and values are the clusters
        '''
        # [[8, 43], [67, 48], [43, 80], [16, 87], [5, 42], [54, 11], [21, 56], [65, 74], [74, 67], [65, 62]]

        n = len(cluster_points)  # n = 10
        centroids = []
        # Time to debug the code
        
        # I need to get k number of points from the dataset to use as centroids
        for i in range(2, len(cluster_points), 2):  # i = 2, 4, 6, 8
            centroids.append(cluster_points[i])
            if len(centroids) == self.k:
                break


        distances = []
        centroid_point_pairs = []
        for point in cluster_points:
            for centroid in centroids:
                dist = euclidian_distance(point, centroid)
                distances.append((dist, point, centroid))  # saving all three just in case
            
            # Distance at this point is now a list of tuples with (distance, point, centroid)
            # This is where I sort and find the closest centroid
            distances.sort(key=lambda x: x[0])
            closest_centroid = distances[0][2]  # Get the closest centroid
            centroid_point_pairs.append([point, closest_centroid])
            distances = []

        # At this point, I have the closest centroid for each point in the dataset
        # Now I need to group the points by their closest centroid
        clusters = {tuple(centroid): [] for centroid in centroids}
        for point, centroid in centroid_point_pairs:
            clusters[tuple(centroid)].append(point)

        return clusters


    def fit(self, X_train):
        # Write you code here
        def cluster_centroid(dataset):
            '''
            # This function will find the cluster centroid for the given training data
            '''
            return [sum(coord) / len(new_cluster) for coord in zip(*dataset)]

        cluster = self.find_cluster_centroid(X_train)
        # cluster = {
        #           (43, 80): [[67, 48], [43, 80], [16, 87], [65, 74], [74, 67], [65, 62]],
        #           (5, 42): [[8, 43], [5, 42]],
        #           (21, 56): [[54, 11], [21, 56]]
        #           }

        dista = True

        while dista:
            updates = {}
            max_shift = 0
            for centroid, new_cluster in cluster.items():
                new_centroid = cluster_centroid(new_cluster)
                distance = euclidian_distance(new_centroid, centroid)
                max_shift = max(max_shift, distance)
                updates[tuple(new_centroid)] = new_cluster
            if max_shift < 0.01:
                dista = False
            else:
                cluster.clear()
                cluster.update(updates)
        
        self.centroids = centroids
    
    def predict(self, X_test):
        pass
'''

if __name__ == "__main__":
    kmeans = KMeans(3)
    cluster_points = [[8, 43], [67, 48], [43, 80], [16, 87], [5, 42], [54, 11], [21, 56], [65, 74], [74, 67], [65, 62]]
    kmeans.find_cluster_centroid(cluster_points)
    # Expected output: centroids and their cluster points